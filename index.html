<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Essay Grader</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script> <!-- Import TensorFlow.js -->
    <style>
        body { font-family: Arial, sans-serif; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px;}
        th, td { border: 1px solid #ccc; padding: 8px; }
        input[type="text"] { width: 100%; }
        #rubric-table input { width: 90%; }
        .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; background-color: rgba(0, 0, 0, 0.4); padding-top: 60px; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close:hover, .close:focus { color: black; text-decoration: none; cursor: pointer; }
    </style>
</head>
<body>

<h2>Essay Grader</h2>
<label>Grade Level: <input type="text" id="grade-level"></label>
<label>Class/Subject: <input type="text" id="class-subject"></label>
<label>Prompt: <input type="text" id="prompt-input"></label>

<h3>Rubric</h3>
<table id="rubric-table">
    <thead>
    <tr>
        <th>Final Grade</th>
        <th><input type="text" value="Criterion 1" class="criterion-name"></th>
    </tr>
    </thead>
    <tbody>
    <tr class="weight-row">
        <td><strong>Weight (% or points)</strong></td>
        <td><input type="text" class="weight-input"></td>
    </tr>
    <tr>
        <td><input type="text" value="Excellent" class="level-name"></td>
        <td><input type="text"></td>
    </tr>
    <tr>
        <td><input type="text" value="Good" class="level-name"></td>
        <td><input type="text"></td>
    </tr>
    <tr>
        <td><input type="text" value="Needs Improvement" class="level-name"></td>
        <td><input type="text"></td>
    </tr>
    </tbody>
</table>
<button id="add-criterion">Add Criterion</button>
<button id="remove-criterion">Remove Criterion</button>
<button id="add-rubric-row">Add Rubric Row</button>

<h3>Essays</h3>
<table id="essay-body">
    <thead>
    <tr>
        <th>Student Name</th>
        <th>Essay</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><input type="text"></td>
        <td><input type="text"></td>
    </tr>
    </tbody>
</table>
<button id="add-essay">Add Essay</button>
<button id="submit-btn">Submit</button>

<div id="output"></div>

<!-- Modal for grading essays -->
<div id="gradeModal" class="modal">
    <div class="modal-content">
        <span class="close">Ã—</span>
        <h3>Grade Essay</h3>
        <label for="student-name">Student Name:</label>
        <input type="text" id="student-name" disabled>

        <label for="overall-grade">Overall Grade:</label>
        <input type="text" id="overall-grade">

        <h4>Subgrades:</h4>
        <div id="subgrades-container"></div>

        <button id="grade-submit">Submit Grade</button>
    </div>
</div>

<script type="module">
    import Groq from "https://cdn.jsdelivr.net/npm/groq-sdk@0.8.0/+esm";

    const encodedApiKey = "Z3NrX21tTzZvWlpXMjdQbkJqTnpyWFVHV0dkeWIzRllsT0Z5TzVBYUtSbldQUGdubkZ5T1hKY2M=";
    const decodedApiKey = atob(encodedApiKey);
    const client = new Groq({ apiKey: decodedApiKey, dangerouslyAllowBrowser: true });

    const rubricTable = document.getElementById('rubric-table').querySelector('tbody');
    const addCriterionBtn = document.getElementById('add-criterion');
    const removeCriterionBtn = document.getElementById('remove-criterion');
    const addRubricRowBtn = document.getElementById('add-rubric-row');
    const addEssayBtn = document.getElementById('add-essay');
    const essayTable = document.getElementById('essay-body').querySelector('tbody');
    const gradeModal = document.getElementById("gradeModal");
    const studentNameInput = document.getElementById("student-name");
    const overallGradeInput = document.getElementById("overall-grade");
    const subgradesContainer = document.getElementById("subgrades-container");
    const closeModal = document.querySelector(".close");
    const gradeSubmit = document.getElementById("grade-submit");

    let selectedEssays = []; // Essays in the grading modal
    let allEssays = []; // Store all essays for Groq grading
    let userGrades = []; // Store grades inputted by the user
    let finalModel = null; // To store the final model for main grade predictions
    let curveModel = null; // To store the model that predicts the curve

    addCriterionBtn.addEventListener('click', () => {
        const headRow = document.querySelector('#rubric-table thead tr');
        const newTh = document.createElement('th');
        const input = document.createElement('input');
        input.classList.add('criterion-name');
        input.type = 'text';
        input.value = `Criterion ${headRow.children.length}`;
        newTh.appendChild(input);
        headRow.appendChild(newTh);

        rubricTable.querySelectorAll('tr').forEach((row) => {
            const newTd = document.createElement('td');
            const textInput = document.createElement('input');
            textInput.type = 'text';
            newTd.appendChild(textInput);
            row.appendChild(newTd);
        });
    });

    removeCriterionBtn.addEventListener('click', () => {
        const headRow = document.querySelector('#rubric-table thead tr');
        const columnCount = headRow.children.length;
        for (let i = 1; i < columnCount; i++) {
            headRow.removeChild(headRow.lastElementChild);
            rubricTable.querySelectorAll('tr').forEach(row => {
                row.removeChild(row.lastElementChild);
            });
        }
    });

    addRubricRowBtn.addEventListener('click', () => {
        const row = document.createElement('tr');
        const tdLabel = document.createElement('td');
        const inputText = document.createElement('input');
        inputText.type = 'text'; // Allow renaming
        tdLabel.appendChild(inputText);
        row.appendChild(tdLabel);

        const columnCount = document.querySelector('#rubric-table thead tr').children.length;
        for (let i = 1; i < columnCount; i++) {
            const td = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'text';
            td.appendChild(input);
            row.appendChild(td);
        }
        rubricTable.appendChild(row);
    });

    addEssayBtn.addEventListener('click', () => {
        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        const essayCell = document.createElement('td');
        nameCell.innerHTML = `<input type="text">`;
        essayCell.innerHTML = `<input type="text">`;
        row.appendChild(nameCell);
        row.appendChild(essayCell);
        essayTable.appendChild(row);
        
        allEssays.push(row); // Store the added essay
    });

    function openGradeModal(selectedEssay) {
        const studentName = selectedEssay.children[0].querySelector('input').value;
        studentNameInput.value = studentName;

        subgradesContainer.innerHTML = '';
        const criteria = Array.from(document.querySelectorAll('.criterion-name'));

        criteria.forEach((criterion, index) => {
            const subgradeDiv = document.createElement('div');
            subgradeDiv.innerHTML = `<label>${criterion.value}</label>: <input type="text" class="subgrade-input" id="subgrade-${index}">`;
            subgradesContainer.appendChild(subgradeDiv);
        });

        gradeModal.style.display = "block";
    }

    closeModal.onclick = function () {
        gradeModal.style.display = "none";
    }

    gradeSubmit.addEventListener('click', async () => {
        const studentName = studentNameInput.value;
        const overallGrade = parseInt(overallGradeInput.value);
        const subgrades = Array.from(subgradesContainer.querySelectorAll('.subgrade-input')).map(input => parseInt(input.value));

        console.log(`Overall Grade for ${studentName}: ${overallGrade}`);
        subgrades.forEach((subgrade, index) => {
            console.log(`Subgrade ${index + 1} for ${studentName}: ${subgrade}`);
        });

        // Save user grades
        userGrades.push({ name: studentName, overall: overallGrade, subgrades });

        // Close the modal
        gradeModal.style.display = "none";

        // After closing the modal, check if we've graded essays
        if (selectedEssays.length > 0) {
            const nextEssay = selectedEssays.shift(); // Pop the next essay from the list
            openGradeModal(nextEssay); // Open for the next essay
        } else {
            console.log("Groq will grade all essays now.");
            await gradeAllEssays(); // Grade all essays in sequence
            await logGradingResults(); // Log grading results after Groq grading is complete
            alert("Grading complete.");
            await trainModel(); // Train the model after grading is complete
        }
    });

    async function gradeAllEssays() {
        for (const essay of allEssays) {
            await gradeWithGroq(essay);
            console.log("\nDone with essay:", essay.children[0].querySelector('input').value);
            await new Promise(resolve => setTimeout(resolve, 200)); // Add a small delay between essays
            console.log("Waiting for next essay...\n");
        }

        alert("Groq has graded all essays.");
        console.log("Groq has successfully graded all essays.");
    }

    async function logGradingResults() {
        console.log("\nFinal Grading Results:");
        
        for (const userGrade of userGrades) {
            const index = allEssays.findIndex(essay => essay.children[0].querySelector('input').value === userGrade.name);
            const groqResponse = await gradeWithGroq(allEssays[index]);
            const groqGradesArray = groqResponse.split(',').map(Number);
            const groqOverall = groqGradesArray[0];

            // Predict the curve using the trained model
            const essayTensor = preprocessText([userGrade.name]);
            const predictedCurve = await finalModel.predict(essayTensor).data(); // Now this is using the main grade model
            const finalGrade = groqOverall * predictedCurve[0]; // Calculate final grade using the curve

            // Log the grading results
            console.log(`Grades for ${userGrade.name}:`);
            console.log(`User Overall Grade: ${userGrade.overall}`);
            console.log(`Groq Overall Grade: ${groqOverall}`);
            console.log(`Predicted Curve: ${predictedCurve[0].toFixed(2)}`);
            console.log(`Calculated Final Grade: ${finalGrade.toFixed(2)}`);
            console.log(`User Subgrades: ${userGrade.subgrades.join(", ")}`);
            console.log(`Groq Subgrades: ${groqGradesArray.slice(1).join(", ")}`); 
            
            userGrade.subgrades.forEach((subgrade, i) => {
                if (i < groqGradesArray.length - 1) {
                    console.log(`Subgrade ${i + 1} User: ${subgrade}, Groq: ${groqGradesArray[i + 1]}, Difference: ${subgrade - groqGradesArray[i + 1]}`);
                } else {
                    console.log(`Subgrade ${i + 1} User: ${subgrade}, Groq: N/A, Difference: N/A`);
                }
            });
        }
    }

    async function trainModel() {
        console.log("Training model...");

        const curveInputEssays = [];
        const curveTargets = [];

        // Collect data for curves (ratio of user grade to Groq grade)
        for (let i = 0; i < userGrades.length; i++) {
            const userGrade = userGrades[i].overall;
            const essay = allEssays[i];
            const groqResponse = await gradeWithGroq(essay);
            const groqGradesArray = groqResponse.split(',').map(Number);
            const groqOverall = groqGradesArray[0];

            // Prevent division by zero and calculate the curve
            if (groqOverall > 0) {
                const curve = userGrade / groqOverall;
                curveInputEssays.push(essay.children[0].querySelector('input').value);
                curveTargets.push(curve);
            }
        }

        const curveInputTensor = preprocessText(curveInputEssays);
        const curveTargetTensor = tf.tensor1d(curveTargets);

        // Build and train the model for curve prediction
        const curveModel = tf.sequential();
        curveModel.add(tf.layers.dense({ inputShape: [1200], units: 1 }));
        curveModel.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

        await curveModel.fit(curveInputTensor, curveTargetTensor, { epochs: 1000 });

        console.log("Curve model training completed!");
        window.curveModel = curveModel; // Store the trained model
    }

    function preprocessText(essays) {
        const tokenizedInputs = essays.map(essay => {
            const words = essay.trim().split(/\s+/);
            const vector = new Array(1200).fill(0);
            words.forEach(word => {
                const index = Math.min(word.length, 1199);
                vector[index] += 1;
            });
            return vector;
        });
        return tf.tensor2d(tokenizedInputs);
    }

    async function gradeWithGroq(essay) {
        const studentName = essay.children[0].querySelector('input').value;

        let systemMessage = `You are an expert essay grader for grade ${document.getElementById('grade-level').value} ${document.getElementById('class-subject').value}. Here is the rubric: ${document.getElementById('rubric-table').outerHTML}. Grade the following essay:`;

        let userMessage = `Essay by ${studentName}: ${essay.children[1].querySelector('input').value}. Use the following format (every grade should be a number out of 100): Comma-separated array (Overall Grade, Subgrade 1, Subgrade 2, etc)\nPrompt: ${document.getElementById("prompt-input").value}`;

        let params = {
            messages: [
                { role: "system", content: systemMessage },
                { role: "user", content: userMessage }
            ],
            model: "llama3-8b-8192"
        };

        let retries = 100;

        while (retries > 0) {
            try {
                console.log("Sending request for", studentName, "with message:", userMessage);
                let chatCompletion = await client.chat.completions.create(params);
                let messageContent = chatCompletion.choices[0].message.content;
                console.log("Received grades from Groq for", studentName, ":", messageContent);
                return messageContent; // Return the raw response for further handling
            } catch (err) {
                if (err.message.includes("429") && retries > 0) {
                    console.warn("Rate limit exceeded. Retrying...");
                    retries--;
                    let backoffTime = 2500; // Wait time before retrying
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                } else {
                    console.error("Error getting feedback for", studentName, ":", err);
                    return; // Exit retry loop if it's not a rate limit error
                }
            }
        }

        console.error(`Failed to receive grades for ${studentName} after multiple retries.`);
    }

    document.getElementById('submit-btn').addEventListener('click', async function () {
        let essays = Array.from(document.querySelectorAll('#essay-body tbody tr'));

        if (essays.length < 8) {
            alert('Please add at least 8 essays before submitting.');
            return;
        }

        selectedEssays = essays.sort(() => 0.5 - Math.random()).slice(0, 8);
        openGradeModal(selectedEssays.shift());
    });
</script>
</body>
</html>
